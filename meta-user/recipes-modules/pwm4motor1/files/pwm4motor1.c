#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/io.h>
#include <linux/interrupt.h>
#include <linux/fs.h>
#include <linux/uaccess.h>

#include <linux/of_address.h>
#include <linux/of_device.h>
#include <linux/of_platform.h>

/* Standard module information, edit as appropriate */
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Xilinx Inc.");
MODULE_DESCRIPTION("my1char - loadable module template generated by petalinux-create -t modules");

#define DRIVER_NAME "pwm4motor1"

//// add to device tree

//   my1char_instance: my1char@41200000 {
//      compatible = "samsolutionvendor,my1char";
    // reg = <0x41200000 0x10000>; 
//  };


/// to add to /dev 
/// cat /proc/devices
// mknod /dev/pwm4motor1 c 243 0
//echo 99000000 > /dev/pwm4motor1    захват 
//echo 80200000 > /dev/pwm4motor1     отпустить
//////////////////////////////////////////



unsigned myint = 0xdeddbbaa;
char *mystr = "default";

module_param(myint, int, S_IRUGO);
module_param(mystr, charp, S_IRUGO);

struct my1char_local {
    int irq;
    unsigned long mem_start;
    unsigned long mem_end;
    void __iomem *base_addr;
};

struct my1char_local *lp = NULL;

volatile static int isOpened=0;



void setValueToAll(unsigned char v0,unsigned char v1,unsigned char v2,unsigned char v3)
{
	  unsigned int * p=lp->base_addr;   
	  *p=v0;       p++; 
      *p=v1;       p++; 
      *p=v2;       p++; 
      *p=v3;       
              

}


ssize_t my1char_read (struct file * filep, char * outb, size_t nbytes, loff_t * offset)
{
    printk(KERN_ALERT " try read in module");

        return -1;

}

ssize_t my1char_write (struct file * filep, const char * inpb, size_t nbytes, loff_t * offset)
{

        
       // printk(KERN_ALERT "wirte address lp=0x%08x | end address=0x%08x | base address=0x%08x",lp->mem_start,lp->mem_end,lp->base_addr);
       // printk(KERN_ALERT "size=%d\n",nbytes);
    

        char input_value[8];
        int i=0;
        for(i=0;i<8;i++)
        {
            get_user(input_value[i],&inpb[i]);
            input_value[i]-='0';
            printk(KERN_ALERT "input value[%d]=%d\n",i,input_value[i]);
        }
        
        unsigned int * p=lp->base_addr; 
        unsigned char v0=input_value[1]+10*input_value[0];      
        unsigned char v1=input_value[3]+10*input_value[2];      
        unsigned char v2=input_value[5]+10*input_value[4];      
        unsigned char v3=input_value[7]+10*input_value[6];      

        setValueToAll(v0,v1,v2,v3);     

        printk(KERN_ALERT "v0=%d v1=%d v2=%d v3=%d \n",v0,v1,v2,v3);

       return 9;
}

int my1char_open (struct inode * inodep, struct file * filep)
{

    if (isOpened)
    {   
        printk(KERN_ALERT "Device my1char alrady opened\n");
        return -EBUSY;
    }
    isOpened=1;
    return 0;
}

int my1char_release (struct inode * inodep, struct file * filep)
{
    isOpened=0;
    printk(KERN_ALERT "Device my1char release\n");
    return 0;
}


struct file_operations fops = {
read: my1char_read,
write: my1char_write,
open: my1char_open,
release: my1char_release
};





static irqreturn_t my1char_irq(int irq, void *lp)
{
    printk("my1char interrupt\n");
    return IRQ_HANDLED;
}

static int my1char_probe(struct platform_device *pdev)
{
    struct resource *r_irq; /* Interrupt resources */
    struct resource *r_mem; /* IO mem resources */
    struct device *dev = &pdev->dev;
    int rc = 0;

    printk("probe pwm4motor!!!!!!!!!!!!!!!!!!!!!\n");

    dev_info(dev, "Device Tree Probing\n");
    /* Get iospace for the device */
    r_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
    if (!r_mem) {
        dev_err(dev, "invalid address\n");
        return -ENODEV;
    }
    lp = (struct my1char_local *) kmalloc(sizeof(struct my1char_local), GFP_KERNEL);
    if (!lp) {
        dev_err(dev, "Cound not allocate my1char device\n");
        return -ENOMEM;
    }
    dev_set_drvdata(dev, lp);
    lp->mem_start = r_mem->start;
    lp->mem_end = r_mem->end;

    if (!request_mem_region(lp->mem_start,
                lp->mem_end - lp->mem_start + 1,
                DRIVER_NAME)) {
        dev_err(dev, "Couldn't lock memory region at %p\n",
            (void *)lp->mem_start);
        rc = -EBUSY;
        goto error1;
    }

    lp->base_addr = ioremap(lp->mem_start, lp->mem_end - lp->mem_start + 1);
    if (!lp->base_addr) {
        dev_err(dev, "my1char: Could not allocate iomem\n");
        rc = -EIO;
        goto error2;
    }

      setValueToAll(50,50,50,50);
      
    dev_info(dev,"my1char at 0x%08x mapped to 0x%08x, irq=%d\n",
        (unsigned int __force)lp->mem_start,
        (unsigned int __force)lp->base_addr,
        0);
    return 0;
error3:
    free_irq(lp->irq, lp);
error2:
    release_mem_region(lp->mem_start, lp->mem_end - lp->mem_start + 1);
error1:
    kfree(lp);
    dev_set_drvdata(dev, NULL);
    return rc;
}

static int my1char_remove(struct platform_device *pdev)
{
    struct device *dev = &pdev->dev;
    setValueToAll(50,50,50,50);
    struct my1char_local *lp = dev_get_drvdata(dev);
    free_irq(lp->irq, lp);
    release_mem_region(lp->mem_start, lp->mem_end - lp->mem_start + 1);
    kfree(lp);
    dev_set_drvdata(dev, NULL);
    return 0;
}


#ifdef CONFIG_OF
static struct of_device_id my1char_of_match[] = {
    { .compatible = "sam_solutions,pwm4motor0", },
    { /* end of list */ },
};
MODULE_DEVICE_TABLE(of, my1char_of_match);
#else
# define my1char_of_match
#endif


static struct platform_driver my1char_driver = {
    .driver = {
        .name = DRIVER_NAME,
        .owner = THIS_MODULE,
        .of_match_table = my1char_of_match,
    },
    .probe      = my1char_probe,
    .remove     = my1char_remove,
};

static int __init my1char_init(void)
{
    printk("init pwm4motor\n");    
    int devnum=register_chrdev(0,DRIVER_NAME,&fops);
    printk(KERN_INFO "major num= %d \n ",devnum);



    return platform_driver_register(&my1char_driver);
    //return 0;
}


static void __exit my1char_exit(void)
{
    platform_driver_unregister(&my1char_driver);
    printk(KERN_ALERT "Goodbye pwm4motor.\n");
}

module_init(my1char_init);
module_exit(my1char_exit);