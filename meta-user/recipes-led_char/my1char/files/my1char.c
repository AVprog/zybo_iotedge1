#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/io.h>
#include <linux/interrupt.h>
#include <linux/fs.h>
#include <linux/uaccess.h>

#include <linux/of_address.h>
#include <linux/of_device.h>
#include <linux/of_platform.h>

/* Standard module information, edit as appropriate */
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Xilinx Inc.");
MODULE_DESCRIPTION("my1char - loadable module template generated by petalinux-create -t modules");

#define DRIVER_NAME "my1char"

//// add to device tree

//   my1char_instance: my1char@41200000 {
//      compatible = "samsolutionvendor,my1char";
    // reg = <0x41200000 0x10000>; 
//  };


/// to add to /dev 
/// cat /proc/devices
// mknod /dev/my1char c 244 0
//////////////////////////////////////////


unsigned myint = 0xdeddbbaa;
char *mystr = "default";

module_param(myint, int, S_IRUGO);
module_param(mystr, charp, S_IRUGO);

struct my1char_local {
    int irq;
    unsigned long mem_start;
    unsigned long mem_end;
    void __iomem *base_addr;
};

struct my1char_local *lp = NULL;

volatile static int isOpened=0;



void OnOffLeds(unsigned char value)
{
	  unsigned int * p=lp->base_addr;   
	  *p=value;       p++;        *p=0x00000000;        p++;        *p=0x00000000;        p++;        *p=0x0000000F;  

}
EXPORT_SYMBOL(OnOffLeds);

ssize_t my1char_read (struct file * filep, char __user * outb, size_t nbytes, loff_t * offset)
{
    printk(KERN_ALERT " try read in module");

        return -1;

}

ssize_t my1char_write (struct file * filep, const char * inpb, size_t nbytes, loff_t * offset)
{

        printk(KERN_ALERT "wirte address lp=0x%08x | end address=0x%08x | base address=0x%08x",lp->mem_start,lp->mem_end,lp->base_addr);
        printk(KERN_ALERT "size=%d\n",nbytes);
    

        char input_value0;
        get_user(input_value0,&inpb[0]);
        printk(KERN_ALERT "input value=%c\n",input_value0);

        unsigned int * p=lp->base_addr;     
    
        if(input_value0=='A')
        {
        *p=0x00000001;
        p++;
        *p=0x00000000;
        p++;
        *p=0x00000000;
        p++;
        *p=0x0000000F;
        }
        if(input_value0=='B')
        {
        *p=0x00000003;
        p++;
        *p=0x00000000;
        p++;
        *p=0x00000000;
        p++;
        *p=0x0000000F;
        }
        if(input_value0=='F')
        {
        *p=0x0000000F;
        p++;
        *p=0x00000000;
        p++;
        *p=0x00000000;
        p++;
        *p=0x0000000F;
        }

        if(input_value0=='0')
        {
        *p=0x00000000;
        p++;
        *p=0x00000000;
        p++;
        *p=0x00000000;
        p++;
        *p=0x0000000F;
        }   
       return 1;
}

int my1char_open (struct inode * inodep, struct file * filep)
{

    if (isOpened)
    {   
        printk(KERN_INFO "Device my1char alrady opened\n");
        return -EBUSY;
    }
    isOpened=1;
    return 0;
}

int my1char_release (struct inode * inodep, struct file * filep)
{
    isOpened=0;
    printk(KERN_ALERT "Device my1char release\n");
    return 0;
}



#define EEP_MAGIC 'E'
#define ERASE_SEQ_NO 0x01
#define RENAME_SEQ_NO 0x02
#define ClEAR_BYTE_SEQ_NO 0x03
#define GET_SIZE 0x04
#define MAX_PART_NAME 32
#define EEP_ERASE _IO(EEP_MAGIC, ERASE_SEQ_NO)
#define EEP_RENAME_PART _IOW(EEP_MAGIC, RENAME_SEQ_NO, unsigned long)
#define EEP_GET_SIZE _IOR(EEP_MAGIC, GET_SIZE, int *)

static long eep_ioctl(struct file *f, unsigned int cmd, unsigned long arg)
{

 char *buf = NULL;

switch(cmd){
    case EEP_ERASE:
        printk("EEP_ERASE");
    break;
    case EEP_RENAME_PART:
        
         buf = kmalloc(MAX_PART_NAME, GFP_KERNEL);
         copy_from_user(buf, (char *)arg, MAX_PART_NAME);
         printk("EEP_RENAME_PART  s=%s",buf);
    break;
    case EEP_GET_SIZE:
         printk("EEP_GET_SIZE");
    break;
default:
return -ENOTTY;
}
return 0;
}

struct file_operations fops = {
read: my1char_read,
write: my1char_write,
open: my1char_open,
release: my1char_release,
.unlocked_ioctl = eep_ioctl,
};





static irqreturn_t my1char_irq(int irq, void *lp)
{
    printk("my1char interrupt\n");
    return IRQ_HANDLED;
}

static int my1char_probe(struct platform_device *pdev)
{
    struct resource *r_irq; /* Interrupt resources */
    struct resource *r_mem; /* IO mem resources */
    struct device *dev = &pdev->dev;
    

    int rc = 0;
    dev_info(dev, "Device Tree Probing\n");
    /* Get iospace for the device */
    r_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
    if (!r_mem) {
        dev_err(dev, "invalid address\n");
        return -ENODEV;
    }
    lp = (struct my1char_local *) kmalloc(sizeof(struct my1char_local), GFP_KERNEL);
    if (!lp) {
        dev_err(dev, "Cound not allocate my1char device\n");
        return -ENOMEM;
    }
    dev_set_drvdata(dev, lp);
    lp->mem_start = r_mem->start;
    lp->mem_end = r_mem->end;

    if (!request_mem_region(lp->mem_start,
                lp->mem_end - lp->mem_start + 1,
                DRIVER_NAME)) {
        dev_err(dev, "Couldn't lock memory region at %p\n",
            (void *)lp->mem_start);
        rc = -EBUSY;
        goto error1;
    }

    lp->base_addr = ioremap(lp->mem_start, lp->mem_end - lp->mem_start + 1);
    if (!lp->base_addr) {
        dev_err(dev, "my1char: Could not allocate iomem\n");
        rc = -EIO;
        goto error2;
    }

        unsigned int * p=lp->base_addr;
        *p=0x00000001;
        p++;
        *p=0x00000000;
        p++;
        *p=0x00000000;
        p++;
        *p=0x0000000F;

    dev_info(dev,"my1char at 0x%08x mapped to 0x%08x, irq=%d\n",
        (unsigned int __force)lp->mem_start,
        (unsigned int __force)lp->base_addr,
        0);
    return 0;
error3:
    free_irq(lp->irq, lp);
error2:
    release_mem_region(lp->mem_start, lp->mem_end - lp->mem_start + 1);
error1:
    kfree(lp);
    dev_set_drvdata(dev, NULL);
    return rc;
}

static int my1char_remove(struct platform_device *pdev)
{
    struct device *dev = &pdev->dev;
    unsigned int * p=lp->base_addr;
    *p=0x00000000;
    p++;
    *p=0x00000000;
    p++;
    *p=0x00000000;
    p++;
    *p=0x0000000F;
    struct my1char_local *lp = dev_get_drvdata(dev);
    free_irq(lp->irq, lp);
    release_mem_region(lp->mem_start, lp->mem_end - lp->mem_start + 1);
    kfree(lp);
    dev_set_drvdata(dev, NULL);
    return 0;
}


#ifdef CONFIG_OF
static struct of_device_id my1char_of_match[] = {
    { .compatible = "sam,my1char", },
    { /* end of list */ },
};
MODULE_DEVICE_TABLE(of, my1char_of_match);
#else
# define my1char_of_match
#endif


static struct platform_driver my1char_driver = {
    .driver = {
        .name = DRIVER_NAME,
        .owner = THIS_MODULE,
        .of_match_table = my1char_of_match,
    },
    .probe      = my1char_probe,
    .remove     = my1char_remove,
};

static int __init my1char_init(void)
{
    printk("<1>Hello module world.\n");
    int devnum=register_chrdev(0,"my1char",&fops);
    printk(KERN_INFO "major num= %d \n ",devnum);



    return platform_driver_register(&my1char_driver);
    //return 0;
}


static void __exit my1char_exit(void)
{
    platform_driver_unregister(&my1char_driver);
    printk(KERN_ALERT "Goodbye module world.\n");
}

module_init(my1char_init);
module_exit(my1char_exit);